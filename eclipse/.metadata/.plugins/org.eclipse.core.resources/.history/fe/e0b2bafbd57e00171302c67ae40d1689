package com.TominoCZ.FBP.particle;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import javax.vecmath.Vector4f;

import org.lwjgl.opengl.GL11;
import org.lwjgl.util.vector.Vector3f;

import com.TominoCZ.FBP.BakedQuadF;
import com.TominoCZ.FBP.FBP;
import com.TominoCZ.FBP.ModelTransformer;
import com.TominoCZ.FBP.VertexF;
import com.TominoCZ.FBP.keys.FBPKeyBindings;
import com.google.common.base.Function;

import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.particle.Particle;
import net.minecraft.client.renderer.BlockModelRenderer;
import net.minecraft.client.renderer.BlockModelShapes;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.VertexBuffer;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.renderer.vertex.VertexFormat;
import net.minecraft.client.renderer.vertex.VertexFormatElement;
import net.minecraft.entity.Entity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec2f;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.animation.FastTESR;
import net.minecraftforge.client.model.pipeline.LightUtil;
import net.minecraftforge.common.model.IModelState;

public class BlockPlaceAnimationDummy extends Particle {

	BlockPos pos;

	IBlockState blockState;

	BlockModelRenderer mr;

	IBakedModel modelPrefab;

	IBakedModel modelForRender;

	List<BakedQuadF> bakedQuadsF;

	Minecraft mc;

	EnumFacing facing;

	Vector3f smoothRot;

	Vector3f prevRot;
	Vector3f rot;

	public BlockPlaceAnimationDummy(World worldIn, double posXIn, double posYIn, double posZIn, IBlockState state) {
		super(worldIn, posXIn, posYIn, posZIn);
		smoothRot = new Vector3f();

		bakedQuadsF = new ArrayList<BakedQuadF>();

		pos = new BlockPos(posXIn, posYIn, posZIn);

		blockState = state;

		mc = Minecraft.getMinecraft();

		mr = mc.getBlockRendererDispatcher().getBlockModelRenderer();

		BlockModelShapes blockModelShapes = mc.getBlockRendererDispatcher().getBlockModelShapes();

		List<BakedQuad> quads = new ArrayList<BakedQuad>();

		modelPrefab = blockModelShapes.getModelForState(state);

		quads.add(modelPrefab.getQuads(state, EnumFacing.UP, 0).get(0));
		quads.add(modelPrefab.getQuads(state, EnumFacing.DOWN, 0).get(0));
		quads.add(modelPrefab.getQuads(state, EnumFacing.EAST, 0).get(0));
		quads.add(modelPrefab.getQuads(state, EnumFacing.NORTH, 0).get(0));
		quads.add(modelPrefab.getQuads(state, EnumFacing.SOUTH, 0).get(0));
		quads.add(modelPrefab.getQuads(state, EnumFacing.WEST, 0).get(0));

		final int QUAD_VERTEXCOUNT = 4;

		for (BakedQuad quad : quads) {
			VertexFormat format = quad.getFormat();
			int[] vData = quad.getVertexData();
			int size = format.getIntegerSize();
			int uv = format.getUvOffsetById(0) / QUAD_VERTEXCOUNT;
			int n = format.getNormalOffset() / QUAD_VERTEXCOUNT;

			BakedQuadF bqf = new BakedQuadF(quad, format, quad.getFace());

			for (int i = 0; i < 4; ++i) {
				// float[] pos = new float[3];
				// float[] normal = new float[3];
				// float[] UV = new float[2];

				// LightUtil.unpack(quad.getVertexData(), pos, format, i, 0);
				// LightUtil.unpack(quad.getVertexData(), normal, format, i, 3);
				// LightUtil.unpack(quad.getVertexData(), UV, format, i, 2);

				// bqf.addVertex(pos[0], pos[1], pos[2], normal[0], normal[1], normal[2], UV[0],
				// UV[1]);

				bqf.addVertex(Float.intBitsToFloat(vData[size * i]), Float.intBitsToFloat(vData[size * i + 1]),
						Float.intBitsToFloat(vData[size * i + 2]),

						((vData[size * i + n]) & 0xFF) / 127f, ((vData[size * i + n] >> 8) & 0xFF) / 127f,
						((vData[size * i + n] >> 16) & 0xFF) / 127f,

						Float.intBitsToFloat(vData[size * i + uv]), Float.intBitsToFloat(vData[size * i + uv + 1]));

			}

			bakedQuadsF.add(bqf);
		}

		modelForRender = ModelTransformer.transform(modelPrefab, blockState, rand.nextLong(),
				new ModelTransformer.IVertexTransformer() {

					@SuppressWarnings("incomplete-switch")
					@Override
					public float[] transform(BakedQuad quad, VertexFormatElement element, float... data) {
						if (element.getUsage() == VertexFormatElement.EnumUsage.POSITION) {
							for (BakedQuadF q : bakedQuadsF) {
								for (VertexF v : q.vertexes) {
									prevRot = new Vector3f();
									rot = new Vector3f();

									facing = mc.thePlayer.getHorizontalFacing();

									switch (facing) {
									case EAST:
										rot.z = -0.15f;
										break;
									case NORTH:
										rot.x = 0.15f;
										break;
									case SOUTH:
										rot.x = -0.15f;
										break;
									case WEST:
										rot.z = 0.15f;
										break;
									}
									
									prevRot.x = rot.x;
									prevRot.y = rot.y;
									
									Vector3f vec = rotatef(new Vector3f(data[0], data[1], data[2]), rot.x, rot.y,
											rot.z);

									return new float[] { vec.x, vec.y, vec.z };
								}
							}
						}

						return data;
					}
				});
		// for (BakedQuad q : quads) {
		// textures.add(q.getSprite());
		// }
	}

	@SuppressWarnings("incomplete-switch")
	@Override
	public void onUpdate() {
		// if (this.particleAge++ >= 60) {
		if (FBPKeyBindings.FBPSweep.isKeyDown())
			this.isExpired = true;

		prevRot.x = rot.x;
		prevRot.y = rot.y;
		prevRot.z = rot.z;

		switch (facing) {
		case EAST:
			rot.z += 0.05f;
			break;
		case NORTH:
			rot.x += -0.05;
			break;
		case SOUTH:
			rot.x += 0.05f;
			break;
		case WEST:
			rot.z += -0.05f;
			break;
		}
	}

	@SuppressWarnings("incomplete-switch")
	@Override
	public void renderParticle(VertexBuffer buff, Entity entityIn, float partialTicks, float rotationX, float rotationZ,
			float rotationYZ, float rotationXY, float rotationXZ) {

		float f = 0, f1 = 0, f2 = 0, f3 = 0;

		float f5 = (float) (prevPosX + (posX - prevPosX) * (double) partialTicks - interpPosX) - 0.5f;
		float f6 = (float) (prevPosY + (posY - prevPosY) * (double) partialTicks - interpPosY) - 0.5f;
		float f7 = (float) (prevPosZ + (posZ - prevPosZ) * (double) partialTicks - interpPosZ) - 0.5f;

		smoothRot.x = ((float) (prevRot.x + (rot.x - prevRot.x) * (double) partialTicks));
		smoothRot.y = ((float) (prevRot.y + (rot.y - prevRot.y) * (double) partialTicks));
		smoothRot.z = ((float) (prevRot.z + (rot.z - prevRot.z) * (double) partialTicks));

		switch (facing) {
		case EAST:
			if (smoothRot.z > 0) {
				this.isExpired = true;
				return;
			}
			break;
		case NORTH:
			if (smoothRot.x < 0) {
				this.isExpired = true;
				return;
			}
			break;
		case SOUTH:
			if (smoothRot.x > 0) {
				this.isExpired = true;
				return;
			}
			break;
		case WEST:
			if (smoothRot.z > 0) {
				this.isExpired = true;
				return;
			}
			break;
		}

		buff.setTranslation(f5 - pos.getX(), f6 - pos.getY(), f7 - pos.getZ());

		Tessellator.getInstance().draw();
		mc.getRenderManager().renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
		buff.begin(GL11.GL_QUADS, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);

		modelForRender = ModelTransformer.transform(modelPrefab, blockState, rand.nextLong(),
				new ModelTransformer.IVertexTransformer() {
					@Override
					public float[] transform(BakedQuad quad, VertexFormatElement element, float... data) {
						if (element.getUsage() == VertexFormatElement.EnumUsage.POSITION) {
							for (BakedQuadF q : bakedQuadsF) {
								for (VertexF v : q.vertexes) {
									Vector3f vec = rotatef(new Vector3f(data[0], data[1], data[2]), smoothRot.x,
											smoothRot.y, smoothRot.z);

									return new float[] { vec.x, vec.y, vec.z };
								}
							}
						}

						return data;
					}
				});

		mr.renderModelSmooth(worldObj, modelForRender, blockState, pos, buff, false, 0);

		Tessellator.getInstance().draw();
		Minecraft.getMinecraft().getTextureManager()
				.bindTexture(new ResourceLocation("textures/particle/particles.png"));
		buff.begin(GL11.GL_QUADS, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);

		buff.setTranslation(0, 0, 0);
	}

	public void putQuad(VertexBuffer buff, double rotX, double rotY, double rotZ, double scale, int j, int k, float r,
			float g, float b, float a, Vec2f[] par, int quadIndex) {

		int i = quadIndex * 4;

		Vec3d v1 = FBP.CUBE[i];
		Vec3d v2 = FBP.CUBE[i + 1];
		Vec3d v3 = FBP.CUBE[i + 2];
		Vec3d v4 = FBP.CUBE[i + 3];

		// v1 = rotatef(v1, (float) Math.toRadians(rotX), (float) Math.toRadians(rotY),
		// (float) Math.toRadians(rotZ));
		// v2 = rotatef(v2, (float) Math.toRadians(rotX), (float) Math.toRadians(rotY),
		// (float) Math.toRadians(rotZ));
		// v3 = rotatef(v3, (float) Math.toRadians(rotX), (float) Math.toRadians(rotY),
		// (float) Math.toRadians(rotZ));
		// v4 = rotatef(v4, (float) Math.toRadians(rotX), (float) Math.toRadians(rotY),
		// (float) Math.toRadians(rotZ));

		addVt(buff, scale, v1, par[0].x, par[0].y, j, k, r, g, b, a);
		addVt(buff, scale, v2, par[1].x, par[1].y, j, k, r, g, b, a);
		addVt(buff, scale, v3, par[2].x, par[2].y, j, k, r, g, b, a);
		addVt(buff, scale, v4, par[3].x, par[3].y, j, k, r, g, b, a);
	}

	private void addVt(VertexBuffer buff, double scale, Vec3d pos, double u, double v, int j, int k, float r, float g,
			float b, float a) { // add vertex to buffer
		buff.pos(pos.xCoord * scale, pos.yCoord * scale, pos.zCoord * scale).tex(u, v).color(r, g, b, a).lightmap(j, k)
				.endVertex();
	}

	Vector3f rotatef(Vector3f pos2, float AngleX, float AngleY, float AngleZ) {
		float sinAngleX = MathHelper.sin(AngleX);
		float sinAngleY = MathHelper.sin(AngleY);
		float sinAngleZ = MathHelper.sin(AngleZ);

		float cosAngleX = MathHelper.cos(AngleX);
		float cosAngleY = MathHelper.cos(AngleY);
		float cosAngleZ = MathHelper.cos(AngleZ);

		Vector3f pos;

		//pos2.x -= 0.5f;
		// pos2.y -= 0.5f;
		//pos2.z -= 0.5f;

		pos = new Vector3f(pos2.x, pos2.y * cosAngleX - pos2.z * sinAngleX, pos2.y * sinAngleX + pos2.z * cosAngleX);
		pos = new Vector3f(pos.x * cosAngleY + pos.z * sinAngleY, pos.y, pos.x * sinAngleY - pos.z * cosAngleY);
		pos = new Vector3f(pos.x * cosAngleZ - pos.y * sinAngleZ, pos.x * sinAngleZ + pos.y * cosAngleZ, pos.z);

		//pos.x += 0.5f;
		// pos.y += 0.5f;
		//pos.z += 0.5f;
		return pos;
	}

	@Override
	public void setExpired() {
	}
}
